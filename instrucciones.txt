PROYECTO INICIAL
================
1. Creamos una carpeta en lib/ llamada models/ y creamos un archivo llamado task.dart

- Creamos la clase Task con sus propiedades: title, isDone, isDeleted.
- Creamos el constructor e inicializamos isDone y isDeleted
- Creamos una copia de la clase con copyWith. Lo que hace copyWith es que no cambia la instancia en la que se 
llama, sino que crea una nueva instancia que comparte valores de campo idénticos al original.

- Creamos el Json Serialization del modelo Task y borramos las líneas que no usaremos, por ejemplo Dart:conveter y las
líneas de abajo que marcan con error.

- Luego a la clase Task la extendemos de Equatable y luego implementamos el método requerido con las propiedades
de Task.

2. En TaskScreen creamos una lista temporal con 3 tareas y luego creamos un List Builder debajo del Center, para
mostrar la lista temporal. Si sale un error ex porque como la lista esta compartiendo el la pantalla con el Chip que 
tenemos arriba, entonces no puede calcular el espacio disponible. Para eso envolvemos el ListView.Builder con el widget
Expand.

IMPLEMENTACION DE BLOC EN LA APP
================================
3. En la carpeta lib/ creamos una carpeta llamada blocs/ y dentro de ella creamos un archivo llamado bloc_exports.dart.
4. Hacemos clic derecho en la carpeta blocs y seleccionamos la opción "Bloc: new bloc" y le colocamos por nombre tasks.
Luego renonbramos la carpeta bloc para que quede como tasks.
5. En el archivo tasks_state creamos una lista de tipo Task llamada allTasks y la colocamos en el constructor y la
iniciamos en una lista vacía, además colocamos esta propiedad en el Equatable. Además borramos la palabra abstract en la
clase TaskState.

    part of 'tasks_bloc.dart';

    class TasksState extends Equatable {
    final List<Task> allTasks;
    const TasksState({this.allTasks = const <Task>[]});

    @override
    List<Object> get props => [allTasks];
    }

6. Luego, implementamos tasks_events, el cual va a tener 3 eventos: AddTask, UpdateTask y DeleteTask.
7. Luego, vamos a implementar tasks_bloc. Aquí nosotros controlamos los eventos y emitimos nuevos estados de tareas.
En cada evento le decimos al bloc que debería hacer, y por cada evento nosotros escribimos su lógica.

La función onAddTask recibe el evento actual y emisor. Aquí solo emitimos nuevo estado con nueva lista de tareas añadiendo
nuevo objecto evento de tarea a la lista total del estado.

Las funciones onUpdateTask y onDeleteTask las dejamos por ahora vacías.

8. En el archivo Task_Screen vamos a extraer el listView.Builder, para eso hacemos CTRL + . en el widget Expanded
que envuelve el listview.Builder y seleccionamos la opcion Extract Widget y escribimos por nombre TasksList. Luego selecciono
toda la clase TasksList y la corto. Luego en la carpeta lib/ creamos una carpeta llamada widgets/ y dentro de ella un
archivo llamado tasks_list.dart y luego pegamos la clase TasksList. En el Task_Screen importamos el TasksList.

9. En el Task_Screen ya no necesitamos la lista task_list, la borramos.

10. En el main.dart, seleccionamos MaterialApp y con CTRL + . seleccionamos bloc_provider y le colocamos como provider
TasksBloc().

11. En el archivo bloc_exports.dart exportamos tasks_bloc y flutter_bloc:

    export './tasks/tasks_bloc.dart';
    export 'package:flutter_bloc/flutter_bloc.dart';

12. Regresamos a main.dart e importamos el archivo bloc_exports.dart. También envolvemos runApp con BlocOverrides.runZoned:

    void main() {
        BlocOverrides.runZoned(
            () => runApp(const MyApp()),
        );
    }

13. Ahora podemos implementar task bloc en TaskScreen, para eso en TaskScreen envolvemos el Scaffold con Bloc_builder y
que reciba TasksBloc y TasksState. Dentro del builder creamos una lista de tipo Task llamada tasksList y la igualamos con
state.allTasks:  final List<Task> taskList = state.allTasks;

Por el momento, vamos a tener una tarea para hacer la prueba y verla en la pantalla, entonces en el main.dart, en el
BlocProvider, cambiamos el parámetro create por este, mientras tanto:

    create: (context) => TasksBloc()..add(AddTask(task: Task(title: 'Task1'))),


AÑADIENDO BOTTOM SHEET PARA NUEVAS TAREAS
=========================================

14. En la pantalla TaskScreen, creamos una función llamada _addTask y un controlador llamado _titleController, todo antes
del método build().

15. Creamos también un FloatingActionButton, el cual permite mostrar el BottomSheet, paera añadir una tarea.

    floatingActionButton: FloatingActionButton(
        onPressed: () => _addTask(context),
        tooltip: 'Add Task',
        child: const Icon(Icons.add),
    ),

16. Como el SingleChildScrollView es muy grande, entonces Extraemos el child en un nuevo widget llamado AddTaskScreen.

17. Debajo del TextField, añadimos 2 botones, uno para cancelar y otro para añadir una tarea.

            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('Cancel'),
                ),
                ElevatedButton(
                  onPressed: () {
                    var task = Task(title: _titleController.text);
                    context.read<TasksBloc>().add(AddTask(task: task));
                    Navigator.pop(context);
                  },
                  child: const Text('Add'),
                ),
              ],
            ),

18. Como AddTaskScreen es muy grande, vamos a pasarlo a un archivo separado, para eso, en la carpeta Screen/ creamos
otro archivo llamado add_task_screen.dart, Luego cortamos la clase AddTaskScreen de la pantalla TaskScreen y la pasamos
al archivo add_task_screen.dart.

Nota: Una cosa importante, en el TaskScreen, cuando se llama a AddTaskScreen, no enviemos el titleController como 
parámetro, lo que hacemos es quitarlo y luego seleccionamos la línea donde declaramos titleController y lo cortamos.
Luego, en el AddTaskScreen, lo pegamos en el metodo build() antes del return. El constructor queda así:

    const AddTaskScreen({Key? key}) : super(key: key);

19. Aqui hay un bug que cuando hacemos un Hot Restart y agregamos una nueva tarea, no escribe. Para eso vamos a TaskScreen
y convertimos la clase para que extienda de StatefulWidget.

20. El IconButton que está en el action del AppBar, llamamos también el método _addTask para que aparezca el BottomSheet:

              IconButton(
                onPressed: () => _addTask(context),
                icon: const Icon(Icons.add),
              ),

IMPLEMENTAR ACTUALIZAR TAREA
============================

21. En el archivo task_bloc.dart escribimos el método _onUpdateTask así:

void _onUpdateTask(UpdateTask event, Emitter<TasksState> emit) {
    final state = this.state;
    final task = event.task;

    List<Task> allTasks = List.from(state.allTasks)..remove(task);
    task.isDone == false
        ? allTasks.add(task.copyWith(isDone: true))
        : allTasks.add(task.copyWith(isDone: false));

    emit(TasksState(allTasks: allTasks));
  }

22. En el widget task_list.dart, la propiedad onchanged del Checkbox del ListTile, lo seteamos así:

  onChanged: (value) {
    context.read<TasksBloc>().add(UpdateTask(task: task));
  },

23. Al probar la app, los Checkbox funcionan raro, ya que al quitarle el check a uno, se los quita al resto.
Para arreglar eso tenemos que usar in indice para saber que tarea estamos haciendo check y luego en vez de
usar add, usamos insert, para colocar tambien el indice:

  void _onUpdateTask(UpdateTask event, Emitter<TasksState> emit) {
    final state = this.state;
    final task = event.task;
    final int index = state.allTasks.indexOf(task);

    List<Task> allTasks = List.from(state.allTasks)..remove(task);
    task.isDone == false
        ? allTasks.insert(index, task.copyWith(isDone: true))
        : allTasks.insert(index, task.copyWith(isDone: false));

    emit(TasksState(allTasks: allTasks));
  }

IMPLEMENTAR BORRAR TAREA
========================

24. En tasks_bloc.dart, escribimos el método _onDeleteTask asi:

  void _onDeleteTask(DeleteTask event, Emitter<TasksState> emit) {
    final state = this.state;

    emit(TasksState(allTasks: List.from(state.allTasks)..remove(event.task)));
  }

25. En el widget task_list.dart, en el ListTile, agregamos otra propiedad llamada onLongPress así:

  onLongPress: (() => context.read<TasksBloc>().add(DeleteTask(task: task))),

26. Removemos la tarea inicial que teníamos en main.dart, para eso, el create de BlocProvider lo dejamos
así:

  create: (context) => TasksBloc(),

ALMACENAR EL ESTADO EN MEMORIA DEL DISPOSITIVO
==============================================

27. En el pubspec.yaml agregamos una nueva dependencia llamada Hydrated_bloc.
28. En bloc_exports.dart exportamos el paquete hydrated_bloc:

    export 'package:hydrated_bloc/hydrated_bloc.dart';

29. Vamos al archivo task_bloc.dart y cambiamos la clase para que extienda de HydratedBloc y luego 
implementamos los 2 requerimientos necesarios.

30. Vamos a task_state.dart y en el nombre de la clase TaskState presionamos CTRL + . y seleccionamos
la opcion Generate JSON serialization y luego hacemos lo siguiente aquí:

  - borramos la línea: import 'dart:convert';
  - borramos esta línea: String toJson() => json.encode(toMap());
  - borramos esta línea: factory TasksState.fromJson(String source) => TasksState.fromMap(json.decode(source) as Map<String, dynamic>);
  - Dejamos los 2 métodos toMap y fromMap así:

  Map<String, dynamic> toMap() {
    return <String, dynamic>{
      'allTasks': allTasks.map((x) => x.toMap()).toList(),
    };
  }

  factory TasksState.fromMap(Map<String, dynamic> map) {
    return TasksState(
      allTasks: List<Task>.from(
        (map['allTasks']?.map<Task>(
          (x) => Task.fromMap(x),
        )),
      ),
    );
  }


31. En task_bloc.dart, los métodos fromJson y toJson los dejamos así:

  @override
  TasksState? fromJson(Map<String, dynamic> json) {
    return TasksState.fromMap(json);
  }

  @override
  Map<String, dynamic>? toJson(TasksState state) {
    return state.toMap();
  }

32. Instalamos el paquete path_provider En main.dart, en la funcion main, dejamos así:

  void main() async {
    WidgetsFlutterBinding.ensureInitialized();
    final storage = await HydratedStorage.build(
        storageDirectory: await getApplicationDocumentsDirectory());
    HydratedBlocOverrides.runZoned(
      () => runApp(const MyApp()),
      storage: storage,
  );
}

33. Al probar la app hasta ahora, hydrated bloc funciona bien, pero tenemos un pequeño bug, cuando añadimos
varias tareas con el mismo nombre, el checkbox no funciona bien al seleccionarlo en esas tareas que son
iguales. Para eso tenemos que añadir un taskId al modelo Task.

34. Vamos al modelo Task y añadimos la propiedad id en la clase Task, en el constructor, en el copyWith, en el
toMap, en el fromMap y en los props.

35. En la carpeta lib/ creamos una carpeta llamada services/ y dentro de ella un archivo llamado guid_gen.dart
el cual contendrá un método llamado generate() el cual genera un número aleatorio de 16 bits.

36. En add_task_screen.dart, el widget ElevatedButton le añadimos el id:

  ElevatedButton(
    onPressed: () {
      var task = Task(
        title: titleController.text,
        id: GUIDGen.generate(), // linea nueva
      );
      context.read<TasksBloc>().add(AddTask(task: task));
      Navigator.pop(context);
    },
    child: const Text('Add'),
  ),

37. 