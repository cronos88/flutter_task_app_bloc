PROYECTO INICIAL
================
1. Creamos una carpeta en lib/ llamada models/ y creamos un archivo llamado task.dart

- Creamos la clase Task con sus propiedades: title, isDone, isDeleted.
- Creamos el constructor e inicializamos isDone y isDeleted
- Creamos una copia de la clase con copyWith. Lo que hace copyWith es que no cambia la instancia en la que se 
llama, sino que crea una nueva instancia que comparte valores de campo idénticos al original.

- Creamos el Json Serialization del modelo Task y borramos las líneas que no usaremos, por ejemplo Dart:conveter y las
líneas de abajo que marcan con error.

- Luego a la clase Task la extendemos de Equatable y luego implementamos el método requerido con las propiedades
de Task.

2. En TaskScreen creamos una lista temporal con 3 tareas y luego creamos un List Builder debajo del Center, para
mostrar la lista temporal. Si sale un error ex porque como la lista esta compartiendo el la pantalla con el Chip que 
tenemos arriba, entonces no puede calcular el espacio disponible. Para eso envolvemos el ListView.Builder con el widget
Expand.

IMPLEMENTACION DE BLOC EN LA APP
================================
3. En la carpeta lib/ creamos una carpeta llamada blocs/ y dentro de ella creamos un archivo llamado bloc_exports.dart.
4. Hacemos clic derecho en la carpeta blocs y seleccionamos la opción "Bloc: new bloc" y le colocamos por nombre tasks.
Luego renonbramos la carpeta bloc para que quede como tasks.
5. En el archivo tasks_state creamos una lista de tipo Task llamada allTasks y la colocamos en el constructor y la
iniciamos en una lista vacía, además colocamos esta propiedad en el Equatable. Además borramos la palabra abstract en la
clase TaskState.

    part of 'tasks_bloc.dart';

    class TasksState extends Equatable {
    final List<Task> allTasks;
    const TasksState({this.allTasks = const <Task>[]});

    @override
    List<Object> get props => [allTasks];
    }

6. Luego, implementamos tasks_events, el cual va a tener 3 eventos: AddTask, UpdateTask y DeleteTask.
7. Luego, vamos a implementar tasks_bloc. Aquí nosotros controlamos los eventos y emitimos nuevos estados de tareas.
En cada evento le decimos al bloc que debería hacer, y por cada evento nosotros escribimos su lógica.

La función onAddTask recibe el evento actual y emisor. Aquí solo emitimos nuevo estado con nueva lista de tareas añadiendo
nuevo objecto evento de tarea a la lista total del estado.

Las funciones onUpdateTask y onDeleteTask las dejamos por ahora vacías.

8. En el archivo Task_Screen vamos a extraer el listView.Builder, para eso hacemos CTRL + . en el widget Expanded
que envuelve el listview.Builder y seleccionamos la opcion Extract Widget y escribimos por nombre TasksList. Luego selecciono
toda la clase TasksList y la corto. Luego en la carpeta lib/ creamos una carpeta llamada widgets/ y dentro de ella un
archivo llamado tasks_list.dart y luego pegamos la clase TasksList. En el Task_Screen importamos el TasksList.

9. En el Task_Screen ya no necesitamos la lista task_list, la borramos.

10. En el main.dart, seleccionamos MaterialApp y con CTRL + . seleccionamos bloc_provider y le colocamos como provider
TasksBloc().

11. En el archivo bloc_exports.dart exportamos tasks_bloc y flutter_bloc:

    export './tasks/tasks_bloc.dart';
    export 'package:flutter_bloc/flutter_bloc.dart';

12. Regresamos a main.dart e importamos el archivo bloc_exports.dart. También envolvemos runApp con BlocOverrides.runZoned:

    void main() {
        BlocOverrides.runZoned(
            () => runApp(const MyApp()),
        );
    }

13. Ahora podemos implementar task bloc en TaskScreen, para eso en TaskScreen envolvemos el Scaffold con Bloc_builder y
que reciba TasksBloc y TasksState. Dentro del builder creamos una lista de tipo Task llamada tasksList y la igualamos con
state.allTasks:  final List<Task> taskList = state.allTasks;

Por el momento, vamos a tener una tarea para hacer la prueba y verla en la pantalla, entonces en el main.dart, en el
BlocProvider, cambiamos el parámetro create por este, mientras tanto:

    create: (context) => TasksBloc()..add(AddTask(task: Task(title: 'Task1'))),


AÑADIENDO BOTTOM SHEET PARA NUEVAS TAREAS
=========================================

14. En la pantalla TaskScreen, creamos una función llamada _addTask y un controlador llamado _titleController, todo antes
del método build().

15. Creamos también un FloatingActionButton, el cual permite mostrar el BottomSheet, paera añadir una tarea.

    floatingActionButton: FloatingActionButton(
        onPressed: () => _addTask(context),
        tooltip: 'Add Task',
        child: const Icon(Icons.add),
    ),

16. Como el SingleChildScrollView es muy grande, entonces Extraemos el child en un nuevo widget llamado AddTaskScreen.

17. Debajo del TextField, añadimos 2 botones, uno para cancelar y otro para añadir una tarea.

            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('Cancel'),
                ),
                ElevatedButton(
                  onPressed: () {
                    var task = Task(title: _titleController.text);
                    context.read<TasksBloc>().add(AddTask(task: task));
                    Navigator.pop(context);
                  },
                  child: const Text('Add'),
                ),
              ],
            ),

18. Como AddTaskScreen es muy grande, vamos a pasarlo a un archivo separado, para eso, en la carpeta Screen/ creamos
otro archivo llamado add_task_screen.dart, Luego cortamos la clase AddTaskScreen de la pantalla TaskScreen y la pasamos
al archivo add_task_screen.dart.

Nota: Una cosa importante, en el TaskScreen, cuando se llama a AddTaskScreen, no enviemos el titleController como 
parámetro, lo que hacemos es quitarlo y luego seleccionamos la línea donde declaramos titleController y lo cortamos.
Luego, en el AddTaskScreen, lo pegamos en el metodo build() antes del return. El constructor queda así:

    const AddTaskScreen({Key? key}) : super(key: key);

19. Aqui hay un bug que cuando hacemos un Hot Restart y agregamos una nueva tarea, no escribe. Para eso vamos a TaskScreen
y convertimos la clase para que extienda de StatefulWidget.

20. El IconButton que está en el action del AppBar, llamamos también el método _addTask para que aparezca el BottomSheet:

              IconButton(
                onPressed: () => _addTask(context),
                icon: const Icon(Icons.add),
              ),

IMPLEMENTAR ACTUALIZAR TAREA
============================

21. En el archivo task_bloc.dart escribimos el método _onUpdateTask así:

void _onUpdateTask(UpdateTask event, Emitter<TasksState> emit) {
    final state = this.state;
    final task = event.task;

    List<Task> allTasks = List.from(state.allTasks)..remove(task);
    task.isDone == false
        ? allTasks.add(task.copyWith(isDone: true))
        : allTasks.add(task.copyWith(isDone: false));

    emit(TasksState(allTasks: allTasks));
  }

22. En el widget task_list.dart, la propiedad onchanged del Checkbox del ListTile, lo seteamos así:

  onChanged: (value) {
    context.read<TasksBloc>().add(UpdateTask(task: task));
  },

23. Al probar la app, los Checkbox funcionan raro, ya que al quitarle el check a uno, se los quita al resto.
Para arreglar eso tenemos que usar in indice para saber que tarea estamos haciendo check y luego en vez de
usar add, usamos insert, para colocar tambien el indice:

  void _onUpdateTask(UpdateTask event, Emitter<TasksState> emit) {
    final state = this.state;
    final task = event.task;
    final int index = state.allTasks.indexOf(task);

    List<Task> allTasks = List.from(state.allTasks)..remove(task);
    task.isDone == false
        ? allTasks.insert(index, task.copyWith(isDone: true))
        : allTasks.insert(index, task.copyWith(isDone: false));

    emit(TasksState(allTasks: allTasks));
  }

IMPLEMENTAR BORRAR TAREA
========================

24. En tasks_bloc.dart, escribimos el método _onDeleteTask asi:

  void _onDeleteTask(DeleteTask event, Emitter<TasksState> emit) {
    final state = this.state;

    emit(TasksState(allTasks: List.from(state.allTasks)..remove(event.task)));
  }

25. En el widget task_list.dart, en el ListTile, agregamos otra propiedad llamada onLongPress así:

  onLongPress: (() => context.read<TasksBloc>().add(DeleteTask(task: task))),

26. Removemos la tarea inicial que teníamos en main.dart, para eso, el create de BlocProvider lo dejamos
así:

  create: (context) => TasksBloc(),

ALMACENAR EL ESTADO EN MEMORIA DEL DISPOSITIVO
==============================================

27. En el pubspec.yaml agregamos una nueva dependencia llamada Hydrated_bloc.
28. En bloc_exports.dart exportamos el paquete hydrated_bloc:

    export 'package:hydrated_bloc/hydrated_bloc.dart';

29. Vamos al archivo task_bloc.dart y cambiamos la clase para que extienda de HydratedBloc y luego 
implementamos los 2 requerimientos necesarios.

30. Vamos a task_state.dart y en el nombre de la clase TaskState presionamos CTRL + . y seleccionamos
la opcion Generate JSON serialization y luego hacemos lo siguiente aquí:

  - borramos la línea: import 'dart:convert';
  - borramos esta línea: String toJson() => json.encode(toMap());
  - borramos esta línea: factory TasksState.fromJson(String source) => TasksState.fromMap(json.decode(source) as Map<String, dynamic>);
  - Dejamos los 2 métodos toMap y fromMap así:

  Map<String, dynamic> toMap() {
    return <String, dynamic>{
      'allTasks': allTasks.map((x) => x.toMap()).toList(),
    };
  }

  factory TasksState.fromMap(Map<String, dynamic> map) {
    return TasksState(
      allTasks: List<Task>.from(
        (map['allTasks']?.map<Task>(
          (x) => Task.fromMap(x),
        )),
      ),
    );
  }


31. En task_bloc.dart, los métodos fromJson y toJson los dejamos así:

  @override
  TasksState? fromJson(Map<String, dynamic> json) {
    return TasksState.fromMap(json);
  }

  @override
  Map<String, dynamic>? toJson(TasksState state) {
    return state.toMap();
  }

32. Instalamos el paquete path_provider En main.dart, en la funcion main, dejamos así:

  void main() async {
    WidgetsFlutterBinding.ensureInitialized();
    final storage = await HydratedStorage.build(
        storageDirectory: await getApplicationDocumentsDirectory());
    HydratedBlocOverrides.runZoned(
      () => runApp(const MyApp()),
      storage: storage,
  );
}

33. Al probar la app hasta ahora, hydrated bloc funciona bien, pero tenemos un pequeño bug, cuando añadimos
varias tareas con el mismo nombre, el checkbox no funciona bien al seleccionarlo en esas tareas que son
iguales. Para eso tenemos que añadir un taskId al modelo Task.

34. Vamos al modelo Task y añadimos la propiedad id en la clase Task, en el constructor, en el copyWith, en el
toMap, en el fromMap y en los props.

35. En la carpeta lib/ creamos una carpeta llamada services/ y dentro de ella un archivo llamado guid_gen.dart
el cual contendrá un método llamado generate() el cual genera un número aleatorio de 16 bits.

36. En add_task_screen.dart, el widget ElevatedButton le añadimos el id:

  ElevatedButton(
    onPressed: () {
      var task = Task(
        title: titleController.text,
        id: GUIDGen.generate(), // linea nueva
      );
      context.read<TasksBloc>().add(AddTask(task: task));
      Navigator.pop(context);
    },
    child: const Text('Add'),
  ),

37. En el task_list.dart, vamos al ListTile del ListView y lo extraemos a un widget llamado TaskTile para
que el ListView quede más simple. Llamamos al widget TaskTile. Luego seleccionamos toda la clase TaskTile y 
la cortamos, luego en la carpeta widgets/ creamos otro archivo llamado task_tile.dart y luego pegamos la
clase TaskTile ahi.

38. En task_screen.dart, vamos al texto del Chip y lo cambiamos para que muestre el número de tareas que
hay: 

  Center(
    child: Chip(
      label: Text('${state.allTasks.length} Tasks'),
    ),
  ),

ADD NAVIGATION DRAWER
=====================
39. En la carpeta screens/ creamos un nuevo archivo llamado my_drawer.dart y creamos un drawer así:

import 'package:flutter/material.dart';

class MyDrawer extends StatelessWidget {
  const MyDrawer({super.key});

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Drawer(
        child: Column(
          children: [
            Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(vertical: 14, horizontal: 20),
              color: Colors.grey,
              child: Text(
                'Text Drawer',
                style: Theme.of(context).textTheme.headline5,
              ),
            ),
            const ListTile(
              leading: Icon(Icons.folder_special),
              title: Text('My Tasks'),
              trailing: Text('0'),
            ),
            const Divider(),
            const ListTile(
              leading: Icon(Icons.delete),
              title: Text('Bin'),
              trailing: Text('0'),
            ),
          ],
        ),
      ),
    );
  }
}

40. En TaskScreen, agregamos el drawer en el Scaffold:

  drawer: const MyDrawer(),

Recycler Bin Folder
-------------------

41. Ahora vamos a implementar el recycle Bin Folder, para eso en la carpeta screens/  creamos un archivo llamado
recycle_bin.dart:

class RecycleBin extends StatelessWidget {
  const RecycleBin({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Recycle Bin'),
        actions: [
          IconButton(
            onPressed: () => {},
            icon: const Icon(Icons.add),
          ),
        ],
      ),
      drawer: const MyDrawer(),
      body: Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: const [
          Center(
            child: Chip(
              label: Text('Tasks'),
            ),
          ),
          TasksList(taskList: []),
        ],
      ),
    );
  }
}

42. Vamos a implementar la rutas de la app, para eso vamos a la carpeta services/ y creamos un archivo
llamado app_router.dart.

43. Antes de implementar las rutas, vamos a darle un id estático a cada página que nosotros vamos a 
navegar:

  - En TasksScreen colocamos la linea despues del constructor: static const id = 'tasks_screen';
  - En RecycleBin colocamos la línea despues del constructor: static const id = 'recycle_bin_screen';
  
44. De vuelta en app_router.dart, creamos las rutas así:

class AppRouter {
  Route? onGenerateRoute(RouteSettings routeSettings) {
    switch (routeSettings.name) {
      case RecycleBin.id:
        return MaterialPageRoute(
          builder: (_) => const RecycleBin(),
        );
      case TaskScreen.id:
        return MaterialPageRoute(
          builder: (_) => const TaskScreen(),
        );
      default:
        return null;
    }
  }
}

45. En el archivo my_drawer, a cada ListTile lo envolvemos con un GestureDetector:

            GestureDetector(
              onTap: () => Navigator.of(context).pushNamed(TaskScreen.id),
              child: const ListTile(
                leading: Icon(Icons.folder_special),
                title: Text('My Tasks'),
                trailing: Text('0'),
              ),
            ),
            const Divider(),
            GestureDetector(
              onTap: () => Navigator.of(context).pushNamed(RecycleBin.id),
              child: const ListTile(
                leading: Icon(Icons.delete),
                title: Text('Bin'),
                trailing: Text('0'),
              ),
            ),

46. En main.dart, hacemos unos cambios:

  - En MyApp colocamos la siguiente propiedad: final AppRouter appRouter; y añadir al constructor required.
  - En MaterialApp colocamos la siguiente propiedad: onGenerateRoute: appRouter.onGenerateRoute,
  - En la funcion main() especificamos el appRoute en el runApp así:

      HydratedBlocOverrides.runZoned(
        () => runApp(
          MyApp(
           appRouter: AppRouter(),
          ),
        ),
        storage: storage,
      );

47. Luego, vamos a implementar los contadores del Drawer, para eso, en MyDrawer, en el primer ListTile
envolvemos el GestureDetector con un BlocBuilder de tipo TasksBloc y TastState, y luego el trailing del
ListTile lo dejamos así: trailing: Text('${state.allTasks.length}'),

48. Para el contador de tareas borradas, en bloc/ vamos a task_state.dart y hacemos lo sigueinte:

  - añadimos otra nueva propiedad llamada removedTasks: final List<Task> removedTasks;
  - luego, la añadimos al constructor:
      const TasksState({
       this.allTasks = const <Task>[],
       this.removedTasks = const <Task>[],
      });
  
  - Añadimos la propiedad al equatable:

      @override
      List<Object> get props => [allTasks, removedTasks];

  - Añadimos también removedTasks al método toMap():

    Map<String, dynamic> toMap() {
      return <String, dynamic>{
        'allTasks': allTasks.map((x) => x.toMap()).toList(),
        'removedTasks': removedTasks.map((x) => x.toMap()).toList(),
      };
    }

  - Añadimos también removedTasks en el método fromMap():

    factory TasksState.fromMap(Map<String, dynamic> map) {
      return TasksState(
        allTasks: List<Task>.from((map['allTasks']?.map<Task>((x) => Task.fromMap(x)))),
        removedTasks: List<Task>.from((map['removedTasks']?.map<Task>((x) => Task.fromMap(x)))),
      );
    }

49. En bloc/tasks_event.dart, creamos una clase llamada RemovedTasks:

  class RemoveTask extends TasksEvent {
    final Task task;

    const RemoveTask({
      required this.task,
    });

    @override
    List<Object> get props => [task];
  }

50. En bloc/tasks_bloc.dart hacemos estos cambios:

  - Agregamos on<RemoveTask>(_onRemoveTask); al comienzo de la clase TasksBloc.
  - Agregamos un método llamado _onRemoveTask:

    void _onRemoveTask(RemoveTask event, Emitter<TasksState> emit) {
      final state = this.state;

      emit(TasksState(
        allTasks: List.from(state.allTasks)..remove(event.task),
        removedTasks: List.from(state.removedTasks)
          ..add(event.task.copyWith(isDeleted: true)),
      ));
    }

51. En my_drawer.dart, envolvemos el GestureDetector del ListTile del delete con BlocBuilder:

    BlocBuilder<TasksBloc, TasksState>(
      builder: (context, state) {
        return GestureDetector(
          onTap: () => Navigator.of(context).pushNamed(RecycleBin.id),
          child: ListTile(
            leading: const Icon(Icons.delete),
            title: const Text('Bin'),
            trailing: Text('${state.removedTasks.length}'),
          ),
        );
      },
    ),

52. En Screens/recycle_bin.dart, hacemos lo siguiente:

  - Envolvemos el Scaffold con un BlocBuilder:

    @override
    Widget build(BuildContext context) {
      return BlocBuilder<TasksBloc, TasksState>(
        builder: (context, state) {
          return Scaffold(
            appBar: AppBar(
          ...

  - El label del Chip lo modificamos así:

    label: Text('${state.removedTasks.length}'),

  - La línea TaskList la dejamos así:

    TasksList(taskList: state.removedTasks),          

53. En el archivo Task_tile.dart, hacemos lo siguiente: 

  - creamos un método llamado _removeOrDeleteTask() antes del método build:

    void _removeOrDeleteTask(BuildContext ctx, Task task) {
      task.isDeleted!
          ? ctx.read<TasksBloc>().add(DeleteTask(task: task))
          : ctx.read<TasksBloc>().add(RemoveTask(task: task));
    }

  - En el evento onLongPress del checkbox lo cambiamos así:

    onLongPress: (() =>
          _removeOrDeleteTask(context, task)),  

54. Probamos la app. Al añadir tareas y luego borramos unas de ellas, en el Drawer aparece la cantidas
de tareas borradas, pero si vamos a añadir otras tareas, la pantalla donde mueestra las tareas borradas
no muestra nada. Eso es un bug, para eso vamos a Tasks_bloc.dart y en el método _onAddTask añadimos
en el emit el removesTasks así:

  void _onAddTask(AddTask event, Emitter<TasksState> emit) {
    final state = this.state;
    emit(TasksState(
      allTasks: List.from(state.allTasks)..add(event.task),
      removedTasks: state.removedTasks,
    ));
  }

55. Probamos la app y al añadir más tareas, la pantalla de Recycle Bin sigue mostrando las tareas borradas.

56. Lo mismo ocurre cuando actualizamos una tarea, se desaparecen las tareas borradas, para eso en El
método _onUpdateTask agregamos el removedTasks así:

  void _onUpdateTask(UpdateTask event, Emitter<TasksState> emit) {
    final state = this.state;
    final task = event.task;
    final int index = state.allTasks.indexOf(task);

    List<Task> allTasks = List.from(state.allTasks)..remove(task);
    task.isDone == false
        ? allTasks.insert(index, task.copyWith(isDone: true))
        : allTasks.insert(index, task.copyWith(isDone: false));

    emit(TasksState(allTasks: allTasks, removedTasks: state.removedTasks)); ----> ESTA LINEA
  }

57. En el método _onRemoveTask lo acondicionamos así:

  void _onDeleteTask(DeleteTask event, Emitter<TasksState> emit) {
    final state = this.state;

    emit(TasksState(
      allTasks: state.allTasks,
      removedTasks: List.from(state.removedTasks)..remove(event.task),
    ));
  }

58. En la pantalla RecycleBin vemos que las tareas borradas tienen checkbox. Esos no las necesitamos,
ya que una tarea borrada no puede ser actualizada, para eso, en list_tile.dart, en el checkbox colocamos 
una condicion de que si la tarea esta borrada entonces no haga nada:

  trailing: Checkbox(
    value: task.isDone,
    onChanged: task.isDeleted == false
        ? (value) {
            context.read<TasksBloc>().add(UpdateTask(task: task));
          }
        : null,
  ),

59. En el Drawer estamos cambiando de una pabtalla a otra. Esto hace que se forme una pila de pantallas,
lo cual puede comprometer el rendimiento en memoria de la app. Para eso, vamos a reemplazar en los
Navigaror, el pushNamed por pushReplacementNamed.

IMPLEMENTAR SWITCH EN EL DRAWER
===============================
60. En my_drawer.dart, debajo del BlocBuilder, colocamos el Widget Swtich

  Switch(value: false, onChanged: (newValue) {}),

61. La clase MyDrawer la convertimos a StatefulWidget. Luego en la clase State, creamos una variable
de tipo bool llamada switchValue y con valor false.

62. El Switch entonces lo dejamos así para utilizar la nueva variable y el setState para cambiar el estado.

  Switch(
    value: switchValue,
    onChanged: (newValue) {
      setState(() {
        switchValue = newValue;
      });
    },
  ),

63. Implementaremos bloc, quiere decir, vamos a crear un nuevo bloc llamado Switch, para ello hacemos clic
derecho en la carpeta blocs/ y seleccionamos la opción Bloc: New Bloc y escribimos por nombre switch. La
carpeta bloc/ que crea le cambiamos el nombre a switch.

64. En el archivo bloc_exports.dart, agregamos otra exportación para el bloc Switch:

  export './switch/switch_bloc.dart';

65. En el archivo switch_state.dart, vamos a crear el estado para el switchValue:

  class SwitchState extends Equatable {
    final bool switchValue;
    const SwitchState({required this.switchValue});

    @override
    List<Object> get props => [switchValue];
  }

  class SwitchInitial extends SwitchState {
    const SwitchInitial({required super.switchValue});
  }

66. En el archivo switch_event.dart, creamos dos eventos, SwitchOnEvent y SwitchOffEvent:

  abstract class SwitchEvent extends Equatable {
    const SwitchEvent();

    @override
    List<Object> get props => [];
  }

  class SwitchOnEvent extends SwitchEvent {}
  class SwitchOffEvent extends SwitchEvent {}

67. En el archivo switch_bloc.dart, vamos a fijar el valor inicial de switchValue a false y a emitir los
eventos:

  class SwitchBloc extends Bloc<SwitchEvent, SwitchState> {
    SwitchBloc() : super(const SwitchInitial(switchValue: false)) {
      on<SwitchOnEvent>((event, emit) {
        emit(
          const SwitchState(switchValue: true),
        );
      });
      on<SwitchOffEvent>((event, emit) {
        emit(
          const SwitchState(switchValue: false),
        );
      });
    }
  }

68. En la carpeta services/ creamos un nuevo archivo llamado app_theme.dart y colocamos los temas de la
app.

69. En el archivo main.dart, vamos a colocar el otro bloc que creamos, pero como tenemos 2 blocs, entonces
en el método Build de MyApp cambiamos el BlocProvider por MultiBlocProvider y colocamos los 2 blocs:

return MultiBlocProvider(
  // create: (context) => TasksBloc(),
  providers: [
    BlocProvider(create: (context) => TasksBloc()),
    BlocProvider(create: (context) => SwitchBloc()),
  ],

70. Ahora, en my_drawer.dart vamos a implementar el Bloc de Switch, para eso envolvemos el widget Switch con
un BlocBuilder y señalamos el bloc SwitchBloc:

  BlocBuilder<SwitchBloc, SwitchState>(
    builder: (context, state) {
      return Switch(
        value: state.switchValue,
        onChanged: (newValue) {
          newValue
              ? context.read<SwitchBloc>().add(SwitchOnEvent())
              : context.read<SwitchBloc>().add(SwitchOffEvent());
        },
      );
    },
  ),

71. También, vamos a convertir la clase MyDrawer a StatelessWidget.

72. Como necesitamos cambiar el tema de la aplicación, entonces tsmbién necesitamos envolver el widget
MaterialApp con un BlocBuilder y usar SwitchBloc, en el archivo main.dart:

    child: BlocBuilder<SwitchBloc, SwitchState>(
      builder: (context, state) {
        return MaterialApp(
          title: 'Flutter Task App',
          theme: state.switchValue
              ? AppThemes.appThemeData[AppTheme.darkTheme]
              : AppThemes.appThemeData[AppTheme.lightTheme],
          home: const TaskScreen(),
          onGenerateRoute: appRouter.onGenerateRoute,
        );
      },
    ),

73. Al probar la app, el switch cambia el tema de claro a oscuro.

