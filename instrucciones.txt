PROYECTO INICIAL
================
1. Creamos una carpeta en lib/ llamada models/ y creamos un archivo llamado task.dart

- Creamos la clase Task con sus propiedades: title, isDone, isDeleted.
- Creamos el constructor e inicializamos isDone y isDeleted
- Creamos una copia de la clase con copyWith. Lo que hace copyWith es que no cambia la instancia en la que se 
llama, sino que crea una nueva instancia que comparte valores de campo idénticos al original.

- Creamos el Json Serialization del modelo Task y borramos las líneas que no usaremos, por ejemplo Dart:conveter y las
líneas de abajo que marcan con error.

- Luego a la clase Task la extendemos de Equatable y luego implementamos el método requerido con las propiedades
de Task.

2. En TaskScreen creamos una lista temporal con 3 tareas y luego creamos un List Builder debajo del Center, para
mostrar la lista temporal. Si sale un error ex porque como la lista esta compartiendo el la pantalla con el Chip que 
tenemos arriba, entonces no puede calcular el espacio disponible. Para eso envolvemos el ListView.Builder con el widget
Expand.

IMPLEMENTACION DE BLOC EN LA APP
================================
3. En la carpeta lib/ creamos una carpeta llamada blocs/ y dentro de ella creamos un archivo llamado bloc_exports.dart.
4. Hacemos clic derecho en la carpeta blocs y seleccionamos la opción "Bloc: new bloc" y le colocamos por nombre tasks.
Luego renonbramos la carpeta bloc para que quede como tasks.
5. En el archivo tasks_state creamos una lista de tipo Task llamada allTasks y la colocamos en el constructor y la
iniciamos en una lista vacía, además colocamos esta propiedad en el Equatable. Además borramos la palabra abstract en la
clase TaskState.

    part of 'tasks_bloc.dart';

    class TasksState extends Equatable {
    final List<Task> allTasks;
    const TasksState({this.allTasks = const <Task>[]});

    @override
    List<Object> get props => [allTasks];
    }

6. Luego, implementamos tasks_events, el cual va a tener 3 eventos: AddTask, UpdateTask y DeleteTask.
7. Luego, vamos a implementar tasks_bloc. Aquí nosotros controlamos los eventos y emitimos nuevos estados de tareas.
En cada evento le decimos al bloc que debería hacer, y por cada evento nosotros escribimos su lógica.

La función onAddTask recibe el evento actual y emisor. Aquí solo emitimos nuevo estado con nueva lista de tareas añadiendo
nuevo objecto evento de tarea a la lista total del estado.

Las funciones onUpdateTask y onDeleteTask las dejamos por ahora vacías.

8. En el archivo Task_Screen vamos a extraer el listView.Builder, para eso hacemos CTRL + . en el widget Expanded
que envuelve el listview.Builder y seleccionamos la opcion Extract Widget y escribimos por nombre TasksList. Luego selecciono
toda la clase TasksList y la corto. Luego en la carpeta lib/ creamos una carpeta llamada widgets/ y dentro de ella un
archivo llamado tasks_list.dart y luego pegamos la clase TasksList. En el Task_Screen importamos el TasksList.

9. En el Task_Screen ya no necesitamos la lista task_list, la borramos.

10. En el main.dart, seleccionamos MaterialApp y con CTRL + . seleccionamos bloc_provider y le colocamos como provider
TasksBloc().

11. En el archivo bloc_exports.dart exportamos tasks_bloc y flutter_bloc:

    export './tasks/tasks_bloc.dart';
    export 'package:flutter_bloc/flutter_bloc.dart';

12. Regresamos a main.dart e importamos el archivo bloc_exports.dart. También envolvemos runApp con BlocOverrides.runZoned:

    void main() {
        BlocOverrides.runZoned(
            () => runApp(const MyApp()),
        );
    }

13. Ahora podemos implementar task bloc en TaskScreen, para eso en TaskScreen envolvemos el Scaffold con Bloc_builder y
que reciba TasksBloc y TasksState. Dentro del builder creamos una lista de tipo Task llamada tasksList y la igualamos con
state.allTasks:  final List<Task> taskList = state.allTasks;

Por el momento, vamos a tener una tarea para hacer la prueba y verla en la pantalla, entonces en el main.dart, en el
BlocProvider, cambiamos el parámetro create por este, mientras tanto:

    create: (context) => TasksBloc()..add(AddTask(task: Task(title: 'Task1'))),


AÑADIENDO BOTTOM SHEET PARA NUEVAS TAREAS
=========================================

14. En la pantalla TaskScreen, creamos una función llamada _addTask y un controlador llamado _titleController, todo antes
del método build().

15. Creamos también un FloatingActionButton, el cual permite mostrar el BottomSheet, paera añadir una tarea.

    floatingActionButton: FloatingActionButton(
        onPressed: () => _addTask(context),
        tooltip: 'Add Task',
        child: const Icon(Icons.add),
    ),

16. Como el SingleChildScrollView es muy grande, entonces Extraemos el child en un nuevo widget llamado AddTaskScreen.

17. Debajo del TextField, añadimos 2 botones, uno para cancelar y otro para añadir una tarea.

            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('Cancel'),
                ),
                ElevatedButton(
                  onPressed: () {
                    var task = Task(title: _titleController.text);
                    context.read<TasksBloc>().add(AddTask(task: task));
                    Navigator.pop(context);
                  },
                  child: const Text('Add'),
                ),
              ],
            ),

18. Como AddTaskScreen es muy grande, vamos a pasarlo a un archivo separado, para eso, en la carpeta Screen/ creamos
otro archivo llamado add_task_screen.dart, Luego cortamos la clase AddTaskScreen de la pantalla TaskScreen y la pasamos
al archivo add_task_screen.dart.

Nota: Una cosa importante, en el TaskScreen, cuando se llama a AddTaskScreen, no enviemos el titleController como 
parámetro, lo que hacemos es quitarlo y luego seleccionamos la línea donde declaramos titleController y lo cortamos.
Luego, en el AddTaskScreen, lo pegamos en el metodo build() antes del return. El constructor queda así:

    const AddTaskScreen({Key? key}) : super(key: key);

19. Aqui hay un bug que cuando hacemos un Hot Restart y agregamos una nueva tarea, no escribe. Para eso vamos a TaskScreen
y convertimos la clase para que extienda de StatefulWidget.

20. El IconButton que está en el action del AppBar, llamamos también el método _addTask para que aparezca el BottomSheet:

              IconButton(
                onPressed: () => _addTask(context),
                icon: const Icon(Icons.add),
              ),

IMPLEMENTAR ACTUALIZAR TAREA
============================

21. En el archivo task_bloc.dart escribimos el método _onUpdateTask así:

void _onUpdateTask(UpdateTask event, Emitter<TasksState> emit) {
    final state = this.state;
    final task = event.task;

    List<Task> allTasks = List.from(state.allTasks)..remove(task);
    task.isDone == false
        ? allTasks.add(task.copyWith(isDone: true))
        : allTasks.add(task.copyWith(isDone: false));

    emit(TasksState(allTasks: allTasks));
  }

22. En el widget task_list.dart, la propiedad onchanged del Checkbox del ListTile, lo seteamos así:

  onChanged: (value) {
    context.read<TasksBloc>().add(UpdateTask(task: task));
  },

23. Al probar la app, los Checkbox funcionan raro, ya que al quitarle el check a uno, se los quita al resto.
Para arreglar eso tenemos que usar in indice para saber que tarea estamos haciendo check y luego en vez de
usar add, usamos insert, para colocar tambien el indice:

  void _onUpdateTask(UpdateTask event, Emitter<TasksState> emit) {
    final state = this.state;
    final task = event.task;
    final int index = state.allTasks.indexOf(task);

    List<Task> allTasks = List.from(state.allTasks)..remove(task);
    task.isDone == false
        ? allTasks.insert(index, task.copyWith(isDone: true))
        : allTasks.insert(index, task.copyWith(isDone: false));

    emit(TasksState(allTasks: allTasks));
  }

IMPLEMENTAR BORRAR TAREA
========================

24. En tasks_bloc.dart, escribimos el método _onDeleteTask asi:

  void _onDeleteTask(DeleteTask event, Emitter<TasksState> emit) {
    final state = this.state;

    emit(TasksState(allTasks: List.from(state.allTasks)..remove(event.task)));
  }

25. En el widget task_list.dart, en el ListTile, agregamos otra propiedad llamada onLongPress así:

  onLongPress: (() => context.read<TasksBloc>().add(DeleteTask(task: task))),

26. Removemos la tarea inicial que teníamos en main.dart, para eso, el create de BlocProvider lo dejamos
así:

  create: (context) => TasksBloc(),

ALMACENAR EL ESTADO EN MEMORIA DEL DISPOSITIVO
==============================================

27. En el pubspec.yaml agregamos una nueva dependencia llamada Hydrated_bloc.
28. En bloc_exports.dart exportamos el paquete hydrated_bloc:

    export 'package:hydrated_bloc/hydrated_bloc.dart';

29. Vamos al archivo task_bloc.dart y cambiamos la clase para que extienda de HydratedBloc y luego 
implementamos los 2 requerimientos necesarios.

30. Vamos a task_state.dart y en el nombre de la clase TaskState presionamos CTRL + . y seleccionamos
la opcion Generate JSON serialization y luego hacemos lo siguiente aquí:

  - borramos la línea: import 'dart:convert';
  - borramos esta línea: String toJson() => json.encode(toMap());
  - borramos esta línea: factory TasksState.fromJson(String source) => TasksState.fromMap(json.decode(source) as Map<String, dynamic>);
  - Dejamos los 2 métodos toMap y fromMap así:

  Map<String, dynamic> toMap() {
    return <String, dynamic>{
      'allTasks': allTasks.map((x) => x.toMap()).toList(),
    };
  }

  factory TasksState.fromMap(Map<String, dynamic> map) {
    return TasksState(
      allTasks: List<Task>.from(
        (map['allTasks']?.map<Task>(
          (x) => Task.fromMap(x),
        )),
      ),
    );
  }


31. En task_bloc.dart, los métodos fromJson y toJson los dejamos así:

  @override
  TasksState? fromJson(Map<String, dynamic> json) {
    return TasksState.fromMap(json);
  }

  @override
  Map<String, dynamic>? toJson(TasksState state) {
    return state.toMap();
  }

32. Instalamos el paquete path_provider En main.dart, en la funcion main, dejamos así:

  void main() async {
    WidgetsFlutterBinding.ensureInitialized();
    final storage = await HydratedStorage.build(
        storageDirectory: await getApplicationDocumentsDirectory());
    HydratedBlocOverrides.runZoned(
      () => runApp(const MyApp()),
      storage: storage,
  );
}

33. Al probar la app hasta ahora, hydrated bloc funciona bien, pero tenemos un pequeño bug, cuando añadimos
varias tareas con el mismo nombre, el checkbox no funciona bien al seleccionarlo en esas tareas que son
iguales. Para eso tenemos que añadir un taskId al modelo Task.

34. Vamos al modelo Task y añadimos la propiedad id en la clase Task, en el constructor, en el copyWith, en el
toMap, en el fromMap y en los props.

35. En la carpeta lib/ creamos una carpeta llamada services/ y dentro de ella un archivo llamado guid_gen.dart
el cual contendrá un método llamado generate() el cual genera un número aleatorio de 16 bits.

36. En add_task_screen.dart, el widget ElevatedButton le añadimos el id:

  ElevatedButton(
    onPressed: () {
      var task = Task(
        title: titleController.text,
        id: GUIDGen.generate(), // linea nueva
      );
      context.read<TasksBloc>().add(AddTask(task: task));
      Navigator.pop(context);
    },
    child: const Text('Add'),
  ),

37. En el task_list.dart, vamos al ListTile del ListView y lo extraemos a un widget llamado TaskTile para
que el ListView quede más simple. Llamamos al widget TaskTile. Luego seleccionamos toda la clase TaskTile y 
la cortamos, luego en la carpeta widgets/ creamos otro archivo llamado task_tile.dart y luego pegamos la
clase TaskTile ahi.

38. En task_screen.dart, vamos al texto del Chip y lo cambiamos para que muestre el número de tareas que
hay: 

  Center(
    child: Chip(
      label: Text('${state.allTasks.length} Tasks'),
    ),
  ),

ADD NAVIGATION DRAWER
=====================
39. En la carpeta screens/ creamos un nuevo archivo llamado my_drawer.dart y creamos un drawer así:

import 'package:flutter/material.dart';

class MyDrawer extends StatelessWidget {
  const MyDrawer({super.key});

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Drawer(
        child: Column(
          children: [
            Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(vertical: 14, horizontal: 20),
              color: Colors.grey,
              child: Text(
                'Text Drawer',
                style: Theme.of(context).textTheme.headline5,
              ),
            ),
            const ListTile(
              leading: Icon(Icons.folder_special),
              title: Text('My Tasks'),
              trailing: Text('0'),
            ),
            const Divider(),
            const ListTile(
              leading: Icon(Icons.delete),
              title: Text('Bin'),
              trailing: Text('0'),
            ),
          ],
        ),
      ),
    );
  }
}

40. En TaskScreen, agregamos el drawer en el Scaffold:

  drawer: const MyDrawer(),

Recycler Bin Folder
-------------------

41. Ahora vamos a implementar el recycle Bin Folder, para eso en la carpeta screens/  creamos un archivo llamado
recycle_bin.dart:

class RecycleBin extends StatelessWidget {
  const RecycleBin({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Recycle Bin'),
        actions: [
          IconButton(
            onPressed: () => {},
            icon: const Icon(Icons.add),
          ),
        ],
      ),
      drawer: const MyDrawer(),
      body: Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: const [
          Center(
            child: Chip(
              label: Text('Tasks'),
            ),
          ),
          TasksList(taskList: []),
        ],
      ),
    );
  }
}

42. Vamos a implementar la rutas de la app, para eso vamos a la carpeta services/ y creamos un archivo
llamado app_router.dart.

43. Antes de implementar las rutas, vamos a darle un id estático a cada página que nosotros vamos a 
navegar:

  - En TasksScreen colocamos la linea despues del constructor: static const id = 'tasks_screen';
  - En RecycleBin colocamos la línea despues del constructor: static const id = 'recycle_bin_screen';
  
44. De vuelta en app_router.dart, creamos las rutas así:

class AppRouter {
  Route? onGenerateRoute(RouteSettings routeSettings) {
    switch (routeSettings.name) {
      case RecycleBin.id:
        return MaterialPageRoute(
          builder: (_) => const RecycleBin(),
        );
      case TaskScreen.id:
        return MaterialPageRoute(
          builder: (_) => const TaskScreen(),
        );
      default:
        return null;
    }
  }
}

45. En el archivo my_drawer, a cada ListTile lo envolvemos con un GestureDetector:

            GestureDetector(
              onTap: () => Navigator.of(context).pushNamed(TaskScreen.id),
              child: const ListTile(
                leading: Icon(Icons.folder_special),
                title: Text('My Tasks'),
                trailing: Text('0'),
              ),
            ),
            const Divider(),
            GestureDetector(
              onTap: () => Navigator.of(context).pushNamed(RecycleBin.id),
              child: const ListTile(
                leading: Icon(Icons.delete),
                title: Text('Bin'),
                trailing: Text('0'),
              ),
            ),

46. En main.dart, hacemos unos cambios:

  - En MyApp colocamos la siguiente propiedad: final AppRouter appRouter; y añadir al constructor required.
  - En MaterialApp colocamos la siguiente propiedad: onGenerateRoute: appRouter.onGenerateRoute,
  - En la funcion main() especificamos el appRoute en el runApp así:

      HydratedBlocOverrides.runZoned(
        () => runApp(
          MyApp(
           appRouter: AppRouter(),
          ),
        ),
        storage: storage,
      );

47. Luego, vamos a implementar los contadores del Drawer, para eso, en MyDrawer, en el primer ListTile
envolvemos el GestureDetector con un BlocBuilder de tipo TasksBloc y TastState, y luego el trailing del
ListTile lo dejamos así: trailing: Text('${state.allTasks.length}'),

48. Para el contador de tareas borradas, en bloc/ vamos a task_state.dart y hacemos lo sigueinte:

  - añadimos otra nueva propiedad llamada removedTasks: final List<Task> removedTasks;
  - luego, la añadimos al constructor:
      const TasksState({
       this.allTasks = const <Task>[],
       this.removedTasks = const <Task>[],
      });
  
  - Añadimos la propiedad al equatable:

      @override
      List<Object> get props => [allTasks, removedTasks];

  - Añadimos también removedTasks al método toMap():

    Map<String, dynamic> toMap() {
      return <String, dynamic>{
        'allTasks': allTasks.map((x) => x.toMap()).toList(),
        'removedTasks': removedTasks.map((x) => x.toMap()).toList(),
      };
    }

  - Añadimos también removedTasks en el método fromMap():

    factory TasksState.fromMap(Map<String, dynamic> map) {
      return TasksState(
        allTasks: List<Task>.from((map['allTasks']?.map<Task>((x) => Task.fromMap(x)))),
        removedTasks: List<Task>.from((map['removedTasks']?.map<Task>((x) => Task.fromMap(x)))),
      );
    }

49. En bloc/tasks_event.dart, creamos una clase llamada RemovedTasks:

  class RemoveTask extends TasksEvent {
    final Task task;

    const RemoveTask({
      required this.task,
    });

    @override
    List<Object> get props => [task];
  }

50. En bloc/tasks_bloc.dart hacemos estos cambios:

  - Agregamos on<RemoveTask>(_onRemoveTask); al comienzo de la clase TasksBloc.
  - Agregamos un método llamado _onRemoveTask:

    void _onRemoveTask(RemoveTask event, Emitter<TasksState> emit) {
      final state = this.state;

      emit(TasksState(
        allTasks: List.from(state.allTasks)..remove(event.task),
        removedTasks: List.from(state.removedTasks)
          ..add(event.task.copyWith(isDeleted: true)),
      ));
    }

51. En my_drawer.dart, envolvemos el GestureDetector del ListTile del delete con BlocBuilder:

    BlocBuilder<TasksBloc, TasksState>(
      builder: (context, state) {
        return GestureDetector(
          onTap: () => Navigator.of(context).pushNamed(RecycleBin.id),
          child: ListTile(
            leading: const Icon(Icons.delete),
            title: const Text('Bin'),
            trailing: Text('${state.removedTasks.length}'),
          ),
        );
      },
    ),

52. En Screens/recycle_bin.dart, hacemos lo siguiente:

  - Envolvemos el Scaffold con un BlocBuilder:

    @override
    Widget build(BuildContext context) {
      return BlocBuilder<TasksBloc, TasksState>(
        builder: (context, state) {
          return Scaffold(
            appBar: AppBar(
          ...

  - El label del Chip lo modificamos así:

    label: Text('${state.removedTasks.length}'),

  - La línea TaskList la dejamos así:

    TasksList(taskList: state.removedTasks),          

53. En el archivo Task_tile.dart, hacemos lo siguiente: 

  - creamos un método llamado _removeOrDeleteTask() antes del método build:

    void _removeOrDeleteTask(BuildContext ctx, Task task) {
      task.isDeleted!
          ? ctx.read<TasksBloc>().add(DeleteTask(task: task))
          : ctx.read<TasksBloc>().add(RemoveTask(task: task));
    }

  - En el evento onLongPress del checkbox lo cambiamos así:

    onLongPress: (() =>
          _removeOrDeleteTask(context, task)),  

54. Probamos la app. Al añadir tareas y luego borramos unas de ellas, en el Drawer aparece la cantidas
de tareas borradas, pero si vamos a añadir otras tareas, la pantalla donde mueestra las tareas borradas
no muestra nada. Eso es un bug, para eso vamos a Tasks_bloc.dart y en el método _onAddTask añadimos
en el emit el removesTasks así:

  void _onAddTask(AddTask event, Emitter<TasksState> emit) {
    final state = this.state;
    emit(TasksState(
      allTasks: List.from(state.allTasks)..add(event.task),
      removedTasks: state.removedTasks,
    ));
  }

55. Probamos la app y al añadir más tareas, la pantalla de Recycle Bin sigue mostrando las tareas borradas.

56. Lo mismo ocurre cuando actualizamos una tarea, se desaparecen las tareas borradas, para eso en El
método _onUpdateTask agregamos el removedTasks así:

  void _onUpdateTask(UpdateTask event, Emitter<TasksState> emit) {
    final state = this.state;
    final task = event.task;
    final int index = state.allTasks.indexOf(task);

    List<Task> allTasks = List.from(state.allTasks)..remove(task);
    task.isDone == false
        ? allTasks.insert(index, task.copyWith(isDone: true))
        : allTasks.insert(index, task.copyWith(isDone: false));

    emit(TasksState(allTasks: allTasks, removedTasks: state.removedTasks)); ----> ESTA LINEA
  }

57. En el método _onRemoveTask lo acondicionamos así:

  void _onDeleteTask(DeleteTask event, Emitter<TasksState> emit) {
    final state = this.state;

    emit(TasksState(
      allTasks: state.allTasks,
      removedTasks: List.from(state.removedTasks)..remove(event.task),
    ));
  }

58. En la pantalla RecycleBin vemos que las tareas borradas tienen checkbox. Esos no las necesitamos,
ya que una tarea borrada no puede ser actualizada, para eso, en list_tile.dart, en el checkbox colocamos 
una condicion de que si la tarea esta borrada entonces no haga nada:

  trailing: Checkbox(
    value: task.isDone,
    onChanged: task.isDeleted == false
        ? (value) {
            context.read<TasksBloc>().add(UpdateTask(task: task));
          }
        : null,
  ),

59. En el Drawer estamos cambiando de una pabtalla a otra. Esto hace que se forme una pila de pantallas,
lo cual puede comprometer el rendimiento en memoria de la app. Para eso, vamos a reemplazar en los
Navigaror, el pushNamed por pushReplacementNamed.

IMPLEMENTAR SWITCH EN EL DRAWER
===============================
60. En my_drawer.dart, debajo del BlocBuilder, colocamos el Widget Swtich

  Switch(value: false, onChanged: (newValue) {}),

61. La clase MyDrawer la convertimos a StatefulWidget. Luego en la clase State, creamos una variable
de tipo bool llamada switchValue y con valor false.

62. El Switch entonces lo dejamos así para utilizar la nueva variable y el setState para cambiar el estado.

  Switch(
    value: switchValue,
    onChanged: (newValue) {
      setState(() {
        switchValue = newValue;
      });
    },
  ),

63. Implementaremos bloc, quiere decir, vamos a crear un nuevo bloc llamado Switch, para ello hacemos clic
derecho en la carpeta blocs/ y seleccionamos la opción Bloc: New Bloc y escribimos por nombre switch. La
carpeta bloc/ que crea le cambiamos el nombre a switch.

64. En el archivo bloc_exports.dart, agregamos otra exportación para el bloc Switch:

  export './switch/switch_bloc.dart';

65. En el archivo switch_state.dart, vamos a crear el estado para el switchValue:

  class SwitchState extends Equatable {
    final bool switchValue;
    const SwitchState({required this.switchValue});

    @override
    List<Object> get props => [switchValue];
  }

  class SwitchInitial extends SwitchState {
    const SwitchInitial({required super.switchValue});
  }

66. En el archivo switch_event.dart, creamos dos eventos, SwitchOnEvent y SwitchOffEvent:

  abstract class SwitchEvent extends Equatable {
    const SwitchEvent();

    @override
    List<Object> get props => [];
  }

  class SwitchOnEvent extends SwitchEvent {}
  class SwitchOffEvent extends SwitchEvent {}

67. En el archivo switch_bloc.dart, vamos a fijar el valor inicial de switchValue a false y a emitir los
eventos:

  class SwitchBloc extends Bloc<SwitchEvent, SwitchState> {
    SwitchBloc() : super(const SwitchInitial(switchValue: false)) {
      on<SwitchOnEvent>((event, emit) {
        emit(
          const SwitchState(switchValue: true),
        );
      });
      on<SwitchOffEvent>((event, emit) {
        emit(
          const SwitchState(switchValue: false),
        );
      });
    }
  }

68. En la carpeta services/ creamos un nuevo archivo llamado app_theme.dart y colocamos los temas de la
app.

69. En el archivo main.dart, vamos a colocar el otro bloc que creamos, pero como tenemos 2 blocs, entonces
en el método Build de MyApp cambiamos el BlocProvider por MultiBlocProvider y colocamos los 2 blocs:

return MultiBlocProvider(
  // create: (context) => TasksBloc(),
  providers: [
    BlocProvider(create: (context) => TasksBloc()),
    BlocProvider(create: (context) => SwitchBloc()),
  ],

70. Ahora, en my_drawer.dart vamos a implementar el Bloc de Switch, para eso envolvemos el widget Switch con
un BlocBuilder y señalamos el bloc SwitchBloc:

  BlocBuilder<SwitchBloc, SwitchState>(
    builder: (context, state) {
      return Switch(
        value: state.switchValue,
        onChanged: (newValue) {
          newValue
              ? context.read<SwitchBloc>().add(SwitchOnEvent())
              : context.read<SwitchBloc>().add(SwitchOffEvent());
        },
      );
    },
  ),

71. También, vamos a convertir la clase MyDrawer a StatelessWidget.

72. Como necesitamos cambiar el tema de la aplicación, entonces tsmbién necesitamos envolver el widget
MaterialApp con un BlocBuilder y usar SwitchBloc, en el archivo main.dart:

    child: BlocBuilder<SwitchBloc, SwitchState>(
      builder: (context, state) {
        return MaterialApp(
          title: 'Flutter Task App',
          theme: state.switchValue
              ? AppThemes.appThemeData[AppTheme.darkTheme]
              : AppThemes.appThemeData[AppTheme.lightTheme],
          home: const TaskScreen(),
          onGenerateRoute: appRouter.onGenerateRoute,
        );
      },
    ),

73. Al probar la app, el switch cambia el tema de claro a oscuro.

ALMACENAR EL ESTADOS DEL SWITCH EN EL DISPOSITIVO CON HYDRATED BLOC
===================================================================

74. En el archivo switch_state.dart hacemos clic en el nombre de la clase SwitchState y hacemos clic
para seleccionar el nombre, luego presionamos CTRL + . y seleccionamos la opcion Generate JSON Serialization.

  - Borramos la línea: import 'dart:convert';
  - Borramos la línea: String toJson() => json.encode(toMap());
  - Borramos la línea: factory SwitchState.fromJson(String source) => SwitchState.fromMap(json.decode(source) as Map<String, dynamic>);

75. En el archivo switch_bloc.dart hacemos lo siguiente: 

  - Cambiamos el extends de SwitchBloc de Bloc a HydratedBloc.
  - Impementamos los 2 métodos obligatorios que nos pide.
  
  @override
  SwitchState? fromJson(Map<String, dynamic> json) {
    return SwitchState.fromMap(json);
  }

  @override
  Map<String, dynamic>? toJson(SwitchState state) {
    return state.toMap();
  }

  AÑADIENDO BOTTOM NAVIGATOR BAR
  ==============================

76. En la carpeta screens/ creamos otro archivo llamado tabs_screen.dart :

  class TabsScreen extends StatelessWidget {
    const TabsScreen({super.key});

    static const id = 'tabs_screen';

    @override
    Widget build(BuildContext context) {
      return Container();
    }
  }

77. En my_drawer.dart, reemplazamos el Navigator de 'my tasks' por esta línea:

  Navigator.of(context).pushReplacementNamed(TabsScreen.id),

78. En el main.dart, cambiamos el home para que apunte a TabsScreen().

79. En task_screen.dart, seleccionamos el método _addTask y lo cortamos. En tabs_screen.dart pegamos el
método antes del método build(). También cambiamos el Container por un Scaffold:

  @override
    Widget build(BuildContext context) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('Tabs Screen'),
          actions: const [],
        ),
      );
    }

80. En tasks_screen.dart, seleccionamos el actions del Scaffold y lo cortamos. Luego lo pegamos en el 
Scaffold de tabs_screen.dart.

81. En tabs_screen.dart, el la propiedad drawer use MyDrawer() y el body TasksScreen(), después lo cambiamos:

  drawer: const MyDrawer(),
  body: const TaskScreen(),

82. En task_screen.dart cortamos el boton FloatingActionButton y luego lo pegamos en tabs_screen.dart.
83. En tabs_screen.dart implementamos la propiedad bottomNavigationBar, debajo del floatingActionButton, y
establecemos las propiedades manualmente. 

      bottomNavigationBar: BottomNavigationBar(
        currentIndex: 0,
        onTap: (index) {},
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.incomplete_circle_sharp),
            label: 'Pending Tasks'
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.done),
            label: 'Completed Tasks'
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.favorite),
            label: 'Favorite Tasks'
          ),
        ],
      ),

84. En services/app_router.dart, cambiamos el segundo case para que ya no sea TasksScreen.id, sino
TabsScreen.id:

      case TabsScreen.id:
        return MaterialPageRoute(
          builder: (_) => const TabsScreen(),
        );

85. Como estamos viendo doble AppBar, entonces vamos a tasks_screen.dart y removemos Scaffold().

Configuración de los Navigator Bars
------------------------------------
86. Cambiamos el nombre del archivo task_screen.dart por pending_tasks_screen.dart y cambiamos también el nombre
de la clase a PendingTasksScreen.

87. Creamos dos nuevos archivos en la carpeta screens/, llamados completed_tasks_screen.dart y
favorite_tasks_screen.dart.

88. PendingScreen lo convertimos a StatelessWidget.
89. Copiamos todo el contenido de pending_screen.dart y lo pegamos en completed_tasks_screen.dart y tambien
en favorite_tasks_screen.dart. Cambiar también los nombres de las clases con su correspondiente nombre.

90. Vamos al archivo tabs_screen.dart y antes del método _addTask() vamos a crear una lista de las
páginas del BottomNavigationBar:

  final List<Map<String, dynamic>> _pageDetails = [
    {'pageName': PendingTasksScreen(), 'title': 'Pending Tasks'},
    {'pageName': CompletedTasksScreen(), 'title': 'Completed Tasks'},
    {'pageName': FavoriteTasksScreen(), 'title': 'Favorite Tasks'},
  ];

91. Luego, creamos una variable que almacena el indice de la página seleccionada.

  var _selectedPageIndex = 0;

92. En el BottomNavigationBar, el current index tome la variable _selectedPageIndex, y en el onTap, que
_selectedPageIndex sea igual al index y dentro de un setState para cambiar que refresque la pantalla. 
Para actualizar _selectedPageIndex, necesitamos cambiar TabsScreen a StatefulWidget:

    currentIndex: _selectedPageIndex,
    onTap: (index) {
      setState(() {
        _selectedPageIndex = index;
      });
    },

93. Ahora, necesitamos cambiar el body de acuerdo al indice de la página seleccionada:

  body: _pageDetails[_selectedPageIndex]['pageName'],

  y el title del Scaffold hacemos lo mismo:

    title: Text(_pageDetails[_selectedPageIndex]['title']),

94. Agregamos unas tareas, pero al hacer clic en cada una de las páginas del BottomNavigationBar, las
mismas tareas se ven, lo cual no es una buena idea, ya que cada página debe de mostrar las tareas pendientes,
las completadas y las favoritas. Para eso, vamos a bloc/tasks_bloc/tasks_state.dart y agergamos las
tareas de completed y favorite. Y cambiamos allTasks por pendingTasks:

class TasksState extends Equatable {
  final List<Task> pendingTasks;
  final List<Task> completedTasks;
  final List<Task> favoriteTasks;
  final List<Task> removedTasks;

  const TasksState({
    this.pendingTasks = const <Task>[],
    this.completedTasks = const <Task>[],
    this.favoriteTasks = const <Task>[],
    this.removedTasks = const <Task>[],
  });

  @override
  List<Object> get props =>
      [pendingTasks, completedTasks, favoriteTasks, removedTasks];

  Map<String, dynamic> toMap() {
    return <String, dynamic>{
      'pendingTasks': pendingTasks.map((x) => x.toMap()).toList(),
      'completedTasks': completedTasks.map((x) => x.toMap()).toList(),
      'favoriteTasks': favoriteTasks.map((x) => x.toMap()).toList(),
      'removedTasks': removedTasks.map((x) => x.toMap()).toList(),
    };
  }

  factory TasksState.fromMap(Map<String, dynamic> map) {
    return TasksState(
      pendingTasks: List<Task>.from(
          (map['pendingTasks']?.map<Task>((x) => Task.fromMap(x)))),
      completedTasks: List<Task>.from(
          (map['completedTasks']?.map<Task>((x) => Task.fromMap(x)))),
      favoriteTasks: List<Task>.from(
          (map['favoriteTasks']?.map<Task>((x) => Task.fromMap(x)))),
      removedTasks: List<Task>.from(
          (map['removedTasks']?.map<Task>((x) => Task.fromMap(x)))),
    );
  }
}

95. Vamos al archivo task_bloc.dart y hacemos unos cambios:

class TasksBloc extends HydratedBloc<TasksEvent, TasksState> {
  TasksBloc() : super(const TasksState()) {
    on<AddTask>(_onAddTask);
    on<UpdateTask>(_onUpdateTask);
    on<DeleteTask>(_onDeleteTask);
    on<RemoveTask>(_onRemoveTask);
  }

  void _onAddTask(AddTask event, Emitter<TasksState> emit) {
    final state = this.state;
    emit(TasksState(
      pendingTasks: List.from(state.pendingTasks)..add(event.task),
      completedTasks: state.completedTasks, // AÑADIR LINEA
      favoriteTasks: state.favoriteTasks, // AÑADIR LINEA
      removedTasks: state.removedTasks,
    ));
  }

  void _onUpdateTask(UpdateTask event, Emitter<TasksState> emit) {
    final state = this.state;
    final task = event.task;
    // final int index = state.pendingTasks.indexOf(task); BORRAR LINEA

    List<Task> pendingTasks = state.pendingTasks; //CAMBIAMOS ESTA LINEA
    List<Task> completedTasks = state.completedTasks; //AÑADIMOS ESTA LINEA
    task.isDone == false
        ? {
            pendingTasks = List.from(pendingTasks)..remove(task),
            completedTasks = List.from(completedTasks)
              ..insert(0, task.copyWith(isDone: true)),
          } //CAMBIAMOS ESTA LINEA
        : {
            completedTasks = List.from(completedTasks)..remove(task),
            pendingTasks = List.from(pendingTasks)
              ..insert(0, task.copyWith(isDone: false)),
          }; // CAMBIAMOS ESTA LINEA

    emit(TasksState(
      pendingTasks: pendingTasks,
      completedTasks: completedTasks, //AÑADIR LINEA
      favoriteTasks: state.favoriteTasks, //AÑADIR LINEA
      removedTasks: state.removedTasks,
    ));
  }

  void _onRemoveTask(RemoveTask event, Emitter<TasksState> emit) {
    final state = this.state;

    emit(TasksState(
      pendingTasks: List.from(state.pendingTasks)..remove(event.task),
      completedTasks: List.from(state.completedTasks)
        ..remove(event.task), // AÑADIR LINEA
      favoriteTasks: List.from(state.favoriteTasks)
        ..remove(event.task), // AÑADIR LINEA
      removedTasks: List.from(state.removedTasks)
        ..add(event.task.copyWith(isDeleted: true)),
    ));
  }

  void _onDeleteTask(DeleteTask event, Emitter<TasksState> emit) {
    final state = this.state;

    emit(TasksState(
      pendingTasks: state.pendingTasks,
      completedTasks: state.completedTasks, // AÑADIR LINEA
      favoriteTasks: state.favoriteTasks, // AÑADIR LINEA
      removedTasks: List.from(state.removedTasks)..remove(event.task),
    ));
  }

  @override
  TasksState? fromJson(Map<String, dynamic> json) {
    return TasksState.fromMap(json);
  }

  @override
  Map<String, dynamic>? toJson(TasksState state) {
    return state.toMap();
  }
}

96. Ahora vamos a la pantalla completed_tasks_screen.dart y cambiamos el BlocBuilder para que
tome el estado de completedTasks:

    return BlocBuilder<TasksBloc, TasksState>(
      builder: (context, state) {
        final List<Task> taskList = state.completedTasks; // cambiamos linea
        return Column(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Center(
              child: Chip(
                label: Text('${taskList.length} Tasks'), // cambiamos linea
              ),
            ),
            TasksList(taskList: taskList),
          ],
        );
      },
    );

97. En la pantalla favorite_tasks_screen.dart hacemos lo mismo en el BlocBuilder:

    return BlocBuilder<TasksBloc, TasksState>(
      builder: (context, state) {
        final List<Task> taskList = state.favoriteTasks; // cambiamos linea
        return Column(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Center(
              child: Chip(
                label: Text('${taskList.length} Tasks'), // cambiamos linea
              ),
            ),
            TasksList(taskList: taskList),
          ],
        );
      },
    );

98. En la pantalla pending_tasks_screen.dart cambiamos el Chip para que muestre las tareas pendientes y
las completadas:

            Center(
              child: Chip(
                label: Text(
                    '${taskList.length} Pending | ${state.completedTasks.length} Completed'),
              ),
            ),

99. En el Drawer hacemos un cambio, para eso vamos al archivo my_drawer.dart y en el trailing del
ListTile de las tareas lo dejamos así:

  child: ListTile(
    leading: const Icon(Icons.folder_special),
    title: const Text('My Tasks'),
    trailing: Text('${state.pendingTasks.length} | ${state.completedTasks.length}'), // cambiamos aqui
  ),

100. Ahora, necesitamos desaparecer el FloatingActionButton en la pagina de completedTasks y
FavoriteTasksScreen, para eso, en tabs_screen.dart colocamos una condicion en el floatingActionButton:

      floatingActionButton: _selectedPageIndex == 0 ? FloatingActionButton(
        onPressed: () => _addTask(context),
        tooltip: 'Add Task',
        child: const Icon(Icons.add),
      ) : null,

EXPANSION PANEL EN LAS TAREAS
=============================
101. Vamos al archivo tasks_list.dart y cortamos todo el widget Expanded y lo pegamos debajo de la clase
TaskList, y comentamos esas líneas. Luego en el return colocamos lo siguiente:

    ExpansionPanelList.radio(
      children: taskList
          .map(
            (task) => ExpansionPanelRadio(
              value: task.id,
              headerBuilder: (context, isOpen) => TaskTile(task: task),
              body: const Text('description'),
            ),
          )
          .toList(),
    );

102. En el modelo vamos a implementar la descripción, para eso abrimos el archivo modesl/task.dark y
añadimos la propiedad description, también agregamos la propiedad description requerida en las demás
partes del modelo.

103. En el archivo add_task_screen.dart, tenemos que usa description, para eso añadimos otro
TextEditingController llamado descriptionController:

  final TextEditingController descriptionController = TextEditingController();

104. Después añadimos otro TextField para la descripción:

  TextField(
    autofocus: true,
    controller: descriptionController,
    minLines: 3,
    maxLines: 5,
    decoration: const InputDecoration(
      label: Text('Description'),
      border: OutlineInputBorder(),
    ),
  ),

105. En el ElevatedButton, agregamos el controlador de descripción:

  ElevatedButton(
    onPressed: () {
      var task = Task(
        title: titleController.text,
        description: descriptionController.text, // linea nueva
        id: GUIDGen.generate(),
      );
      context.read<TasksBloc>().add(AddTask(task: task));
      Navigator.pop(context);
    },
    child: const Text('Add'),
  ),

106. Al agregar una tarea, los botones no se ven, están muy abajo. Para eso vamos al archivo tabs_screen.dart
y en el método _addTask, vamos a showModalBottomSheet y añadimos la propiedad isScrollControlled a true:

void _addTask(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,  // nueva línea
      builder: ((context) => const SingleChildScrollView(
            child: AddTaskScreen(),
          )),
    );
  }

107.Nos vamos al archivo tasksList.dart y cambiamos el body del ExpansionPanelRadio para albergar la
descripción:

    body: ListTile(
      title: SelectableText.rich(
        TextSpan(
          children: [
            const TextSpan(
              text: 'Text\n',
              style: TextStyle(
                fontWeight: FontWeight.bold,
              ),
            ),
            TextSpan(text: task.title),
            const TextSpan(
              text: '\n\nDescription\n',
              style: TextStyle(
                fontWeight: FontWeight.bold,
              ),
            ),
            TextSpan(text: task.description),
          ],
        ),
      ),
    ),

108. Al agregar tareas, vemos que se produce un error de overflow o desbordamiento, para eso hay que 
envolver el widget ExpansionPanelList.radio con un SingleChildScrollView y luego envolver este con un
Expanded.

109. Si agregamos un texto muy grande en las tareas, se producen 2 líneas. Para eso en el archivo 
task_tile.dart agregamos un overflow al texto del título del ListTile:

  overflow: TextOverflow.ellipsis,




